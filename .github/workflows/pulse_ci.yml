name: PULSE CI

on:
  push:
    branches: [main]
    tags: ["v*", "V*"]
    paths-ignore:
      - "docs/**"
      - "**/*.md"
      - "badges/**"
      - "reports/**"
      - "!docs/policy/CHANGELOG.md"

  pull_request:
    branches: [main]

  workflow_dispatch:
    inputs:
      strict_external_evidence:
        description: "Require external *_summary.json evidence (fail if missing)"
        required: false
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Least privilege by default: this workflow must not write to the repo.
permissions:
  contents: read

jobs:
  pulse:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # pinned
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Enforce changelog for policy/spec changes
        shell: bash
        run: |
          set -euo pipefail

          # Determine diff range depending on event type.
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
          else
            echo "Skipping changelog enforcement: unsupported event '${{ github.event_name }}'."
            exit 0
          fi

          # Handle edge cases (e.g., first commit or unusual events).
          if [[ -z "${BASE}" || "${BASE}" == "0000000000000000000000000000000000000000" ]]; then
            echo "Skipping changelog enforcement: BASE SHA is empty/zero."
            exit 0
          fi

          echo "Changelog enforcement diff range: ${BASE}..${HEAD}"

          CHANGED="$(git diff --name-only "${BASE}" "${HEAD}" || true)"
          echo "${CHANGED}" | sed 's/^/changed: /' || true

          # Files that can change release-gating meaning and therefore require changelog coverage.
          SEMANTIC_PATTERN='^(pulse_gate_policy_v0\.yml|metrics/specs/|schemas/dataset_manifest\.schema\.json|examples/dataset_manifest\.example\.json)'

          # Changelog file containing semantic change notes.
          CHANGELOG_PATH='docs/policy/CHANGELOG.md'

          # If nothing semantic changed, do nothing.
          SEMANTIC_CHANGED="$(echo "${CHANGED}" | grep -E "${SEMANTIC_PATTERN}" || true)"
          if [[ -z "${SEMANTIC_CHANGED}" ]]; then
            echo "No semantic policy/spec/contract changes detected; changelog update not required."
            exit 0
          fi

          if [[ ! -f "${CHANGELOG_PATH}" ]]; then
            echo "::error::Changelog not found at ${CHANGELOG_PATH}."
            exit 1
          fi

          export SEMANTIC_CHANGED
          export CHANGELOG_PATH

          python3 - <<'PY'
          import os, re, sys
          from pathlib import Path

          changed = [ln.strip() for ln in os.environ["SEMANTIC_CHANGED"].splitlines() if ln.strip()]
          changelog_path = Path(os.environ["CHANGELOG_PATH"])
          text = changelog_path.read_text(encoding="utf-8", errors="replace")

          # Accept both "## Unreleased" and "## [Unreleased]" (robust, not brittle).
          m = re.search(r"^##\s*\[?\s*Unreleased\s*\]?\s*$([\s\S]*?)(?=^##\s+\S|\Z)", text, flags=re.M | re.I)
          if not m:
            print("::error::docs/policy/CHANGELOG.md is missing an 'Unreleased' section (expected '## Unreleased' or '## [Unreleased]').")
            sys.exit(1)

          unrel = m.group(1)
          unrel_l = unrel.lower()

          def stem_variants(stem: str):
            s = stem.lower()
            s2 = re.sub(r"_v\d+$", "", s)  # drop _v0 suffix (q3_fairness_v0 -> q3_fairness)
            return {
              s,
              s2,
              s2.replace("_", " "),
              s2.replace("_", "-"),
            }

          def parse_spec_id_version(path: Path):
            # Minimal YAML parsing for the spec block: look for top-level "spec:" then id/version inside.
            in_spec = False
            spec_id = None
            spec_ver = None

            for raw in path.read_text(encoding="utf-8", errors="replace").splitlines():
              line = raw.rstrip("\n")

              # enter spec block on exact top-level "spec:"
              if not in_spec and re.match(r"^spec:\s*$", line):
                in_spec = True
                continue

              if in_spec:
                # leaving spec block when another top-level key starts (non-empty and no leading spaces)
                if re.match(r"^[A-Za-z0-9_]+\s*:\s*$", line) and not line.startswith(" "):
                  break

                # capture id and version lines inside spec
                m_id = re.match(r"^\s*id:\s*(.+?)\s*$", line)
                if m_id and spec_id is None:
                  spec_id = m_id.group(1).strip().strip('"').strip("'")
                  continue

                m_ver = re.match(r"^\s*version:\s*(.+?)\s*$", line)
                if m_ver and spec_ver is None:
                  spec_ver = m_ver.group(1).strip().strip('"').strip("'")
                  continue

                if spec_id and spec_ver:
                  break

            return spec_id, spec_ver

          def parse_policy_id_version(path: Path):
            # Minimal YAML parsing for the policy block: look for top-level "policy:" then id/version inside.
            in_policy = False
            pol_id = None
            pol_ver = None

            for raw in path.read_text(encoding="utf-8", errors="replace").splitlines():
              line = raw.rstrip("\n")

              # enter policy block on exact top-level "policy:"
              if not in_policy and re.match(r"^policy:\s*$", line):
                in_policy = True
                continue

              if in_policy:
                # leaving policy block when another top-level key starts (non-empty and no leading spaces)
                if re.match(r"^[A-Za-z0-9_]+\s*:\s*$", line) and not line.startswith(" "):
                  break

                m_id = re.match(r"^\s*id:\s*(.+?)\s*$", line)
                if m_id and pol_id is None:
                  pol_id = m_id.group(1).strip().strip('"').strip("'")
                  continue

                m_ver = re.match(r"^\s*version:\s*(.+?)\s*$", line)
                if m_ver and pol_ver is None:
                  pol_ver = m_ver.group(1).strip().strip('"').strip("'")
                  continue

                if pol_id and pol_ver:
                  break

            return pol_id, pol_ver

          missing = []

          for p in changed:
            if p.startswith("metrics/specs/") and p.endswith(".yml"):
              spec_path = Path(p)
              if not spec_path.exists():
                missing.append((p, "spec file missing in workspace"))
                continue

              spec_id, spec_ver = parse_spec_id_version(spec_path)

              # Fallbacks: use filename stem if spec.id missing (but warn via error).
              file_stem = spec_path.stem.lower()
              want_any = set()

              if spec_id:
                want_any |= stem_variants(spec_id)
              else:
                want_any |= stem_variants(file_stem)

              # Require at least one identifier token AND the version string to appear in Unreleased.
              id_ok = any(tok and tok in unrel_l for tok in want_any)
              ver_ok = (spec_ver is not None) and (str(spec_ver).strip() in unrel)

              if not id_ok or not ver_ok:
                reason = []
                if not id_ok:
                  reason.append(f"missing id token (expected one of: {sorted(want_any)})")
                if spec_ver is None:
                  reason.append("missing spec.version in file")
                elif not ver_ok:
                  reason.append(f"missing version '{spec_ver}' in Unreleased")
                missing.append((p, "; ".join(reason)))
            elif p == "pulse_gate_policy_v0.yml":
              pol_path = Path(p)
              if not pol_path.exists():
                missing.append((p, "policy file missing in workspace"))
                continue

              pol_id, pol_ver = parse_policy_id_version(pol_path)

              if pol_id is None:
                # fallback to file stem
                pol_id = pol_path.stem
              want_any = stem_variants(pol_id)
              id_ok = any(tok and tok in unrel_l for tok in want_any)
              ver_ok = (pol_ver is not None) and (str(pol_ver).strip() in unrel)

              if not id_ok or not ver_ok:
                reason = []
                if not id_ok:
                  reason.append(f"missing policy id token (expected one of: {sorted(want_any)})")
                if pol_ver is None:
                  reason.append("missing policy.version in file")
                elif not ver_ok:
                  reason.append(f"missing version '{pol_ver}' in Unreleased")
                missing.append((p, "; ".join(reason)))
            elif p in ("schemas/dataset_manifest.schema.json", "examples/dataset_manifest.example.json"):
              key = Path(p).stem.replace(".", " ").replace("_", " ").lower()
              if key not in unrel_l:
                missing.append((p, f"missing '{key}' mention in Unreleased"))

          if missing:
            print("::error::Changelog is missing required Unreleased notes for semantic changes:")
            for p, reason in missing:
              print(f"  - {p}: {reason}")
            sys.exit(1)

          print("Changelog enforcement: OK")
          PY

      - name: Install system deps
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # pinned
        with:
          python-version: "3.11"

      - name: Install Python deps
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt
          python -m pip install jsonschema

      - name: Prepare pack dir (workspace)
        shell: bash
        run: |
          set -euo pipefail

          ROOT="$GITHUB_WORKSPACE"
          PACK_DIR="${ROOT}/PULSE_safe_pack_v0"
          echo "PACK_DIR=$PACK_DIR" >> "$GITHUB_ENV"

          if [ ! -d "$PACK_DIR" ]; then
            echo "::error::PACK_DIR not found at $PACK_DIR"
            exit 1
          fi

          echo "PACK_DIR=$PACK_DIR"
      - name: CI pack layout preflight (fail-closed on release-grade)
        shell: bash
        run: |
          set -euo pipefail

          IS_RELEASE=0
          if [[ "${GITHUB_REF:-}" == refs/tags/v* || "${GITHUB_REF:-}" == refs/tags/V* ]]; then
            IS_RELEASE=1
          fi

          if [[ "${GITHUB_EVENT_NAME:-}" == "workflow_dispatch" ]]; then
            STRICT="$(jq -r '.inputs.strict_external_evidence // "false"' "$GITHUB_EVENT_PATH")"
            if [[ "$STRICT" == "true" ]]; then
              IS_RELEASE=1
            fi
          fi

          EXTRA=()
          if (( IS_RELEASE )); then
            EXTRA+=(--release-grade)
          fi

          python tools/check_pack_layout.py --pack_dir "${{ env.PACK_DIR }}" "${EXTRA[@]}"

      - name: Run pack gating pipeline
        shell: bash
        run: |
          set -euo pipefail
          MODE="core"

           # version tag => prod
           if [[ "${GITHUB_REF:-}" == refs/tags/v* || "${GITHUB_REF:-}" == refs/tags/V* ]]; then
            MODE="prod"
           fi

           # strict workflow_dispatch => prod
           if [[ "${GITHUB_EVENT_NAME:-}" == "workflow_dispatch" ]]; then
             STRICT="$(jq -r '.inputs.strict_external_evidence // "false"' "$GITHUB_EVENT_PATH")"
             if [[ "$STRICT" == "true" ]]; then
               MODE="prod"
             fi                                                                                                                                                                                                                                                                                                                                   
           fi  
           echo "Running pack in mode: $MODE"

          python "${{ env.PACK_DIR }}/tools/run_all.py" \
            --mode "$MODE" \
            --pack_dir "${{ env.PACK_DIR }}" \
            --gate_policy "${GITHUB_WORKSPACE}/pulse_gate_policy_v0.yml"

          python "${{ env.PACK_DIR }}/tools/run_all.py" \
            --pack_dir "${{ env.PACK_DIR }}" \
            --gate_policy "$GITHUB_WORKSPACE/pulse_gate_policy_v0.yml"
      
      - name: Preserve baseline status.json (pre-augment)
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ env.PACK_DIR }}/artifacts/status.json"
          DST="${{ env.PACK_DIR }}/artifacts/status_baseline.json"

          if [ ! -f "$SRC" ]; then
            echo "::error::status.json not found at $SRC"
            exit 1
          fi

          cp "$SRC" "$DST"
          echo "OK: wrote $DST"

      - name: "ci: schema validate status_baseline.json (status_v1)"
        shell: bash
        run: |
          set -euo pipefail
          python tools/validate_status_schema.py \
            --schema "$GITHUB_WORKSPACE/schemas/status/status_v1.schema.json" \
            --status "${{ env.PACK_DIR }}/artifacts/status_baseline.json"
    
      - name: "ci: require prod run_mode on release-grade runs"
        if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/tags/V') || (github.event_name == 'workflow_dispatch' && github.event.inputs.strict_external_evidence == 'true')
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, sys
          p="PULSE_safe_pack_v0/artifacts/status.json"
          s=json.load(open(p,"r",encoding="utf-8"))
          m=(s.get("metrics") or {})
          mode=str(m.get("run_mode","")).lower()
          if mode != "prod":
            print(f"::error::release-grade run requires metrics.run_mode='prod' (got '{mode}')")
            sys.exit(1)
          print("OK: run_mode=prod")
          PY

      - name: Show main status.json (head)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "----- status.json (head) -----"
          head -n 200 "${{ env.PACK_DIR }}/artifacts/status.json" || true
          echo "-------------------------------"

      - name: Compute external evidence list (for snapshot)
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          EXTERNAL_DIR="${{ env.PACK_DIR }}/artifacts/external"
          SCRIPT="${{ env.PACK_DIR }}/tools/external_evidence_list.py"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::external_evidence_list.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status.json not found at $STATUS; skipping external evidence list."
            exit 0
          fi

          python "$SCRIPT" \
            --status "$STATUS" \
            --external_dir "$EXTERNAL_DIR"

      - name: Export baseline summary for snapshot (pre-augment)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/status_to_summary.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status_baseline.json"
          OUT_MD="${{ env.PACK_DIR }}/artifacts/status_summary_baseline.md"
          OUT_JSON="${{ env.PACK_DIR }}/artifacts/status_summary_baseline.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::status_to_summary.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status_baseline.json not found at $STATUS; skipping baseline summary."
            exit 0
          fi

          python "$SCRIPT" \
            --status "$STATUS" \
            --out_md "$OUT_MD" \
            --out_json "$OUT_JSON"


      - name: Update artifacts for snapshot
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/update_artifacts_for_snapshot.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::update_artifacts_for_snapshot.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status.json not found at $STATUS; skipping update_artifacts_for_snapshot."
            exit 0
          fi

          python "$SCRIPT" \
            --status "$STATUS"

      - name: Write separation overlay and summary
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/compute_separation_phase_overlay_v0.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::compute_separation_phase_overlay_v0.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status.json not found at $STATUS; skipping separation overlay."
            exit 0
          fi

          python "$SCRIPT" \
            --status "$STATUS"

      - name: Show separation-phase overlay
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "----- separation_phase_overlay_v0.md -----"
          cat "${{ env.PACK_DIR }}/artifacts/separation_phase_overlay_v0.md" || true
          echo "-----------------------------------------"

      - name: Write audit-metric summary
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/audit_metric_summary.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::audit_metric_summary.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status.json not found at $STATUS; skipping audit-metric summary."
            exit 0
          fi

          python "$SCRIPT" \
            --status "$STATUS"

      - name: Show audit-metric summary
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "----- audit_metric_summary.json -----"
          cat "${{ env.PACK_DIR }}/artifacts/audit_metric_summary.json" || true
          echo "-------------------------------------"

      - name: Write refusal-delta summary
        shell: bash
        run: |
          set -euo pipefail

          # Release-grade runs:
          # - version tags (v*/V*)
          # - workflow_dispatch with strict_external_evidence=true
          IS_RELEASE=0
          if [[ "${GITHUB_REF:-}" == refs/tags/v* || "${GITHUB_REF:-}" == refs/tags/V* ]]; then
            IS_RELEASE=1
          fi
          if [[ "${GITHUB_EVENT_NAME:-}" == "workflow_dispatch" ]]; then
            STRICT="$(jq -r '.inputs.strict_external_evidence // "false"' "$GITHUB_EVENT_PATH")"
            if [[ "$STRICT" == "true" ]]; then
              IS_RELEASE=1
            fi
          fi

          POLICY="${GITHUB_WORKSPACE}/pulse_gate_policy_v0.yml"
          PAIRS_SCRIPT="${{ env.PACK_DIR }}/tools/policy_to_refusal_pairs.py"
          RD="${{ env.PACK_DIR }}/tools/refusal_delta.py"
          POLCFG="${{ env.PACK_DIR }}/profiles/pulse_policy.yaml"

          OUT="${{ env.PACK_DIR }}/artifacts/refusal_delta_summary.json"
          PAIRS_FILE="${{ env.PACK_DIR }}/examples/refusal_pairs.jsonl"

          if [ ! -f "$RD" ]; then
            if (( IS_RELEASE )); then
              echo "::error::refusal_delta.py not found at $RD"
              exit 1
            fi
            echo "::warning::refusal_delta.py not found at $RD; skipping refusal-delta."
            exit 0
          fi

          if [ ! -f "$POLCFG" ]; then
            if (( IS_RELEASE )); then
              echo "::error::policy config not found at $POLCFG"
              exit 1
            fi
            echo "::warning::policy config not found at $POLCFG; skipping refusal-delta."
            exit 0
          fi

          # 1) Try to derive pairs from policy (preferred if available)
          PAIRS=""
          if [ -f "$PAIRS_SCRIPT" ] && [ -f "$POLICY" ]; then
            PAIRS="$(python "$PAIRS_SCRIPT" --policy "$POLICY" || true)"
          fi

          # 2) Fallback: if the pack ships a pairs file, use it
          if [[ -z "${PAIRS}" && -f "$PAIRS_FILE" ]]; then
            echo "::notice::policy-derived pairs empty; using pairs file: $PAIRS_FILE"
            PAIRS="$PAIRS_FILE"
          fi

          # 3) If still no pairs: release-grade => fail, otherwise => skip
          if [[ -z "${PAIRS}" ]]; then
            if (( IS_RELEASE )); then
              echo "::error::refusal-delta pairs are required on release-grade runs, but no pairs source was found."
              echo "::error::Expected either non-empty output from $PAIRS_SCRIPT (policy: $POLICY) or file $PAIRS_FILE"
              exit 1
            fi
            echo "::warning::No refusal-delta pairs available; skipping refusal-delta summary."
            exit 0
          fi

          # 4) Compute summary
          python "$RD" \
            --pairs "$PAIRS" \
            --out "$OUT" \
            --policy_config "$POLCFG"

          # 5) Postcondition: summary must exist on release-grade runs (fail-closed)
          if [ ! -f "$OUT" ]; then
            if (( IS_RELEASE )); then
              echo "::error::refusal_delta_summary.json was not created at $OUT"
              exit 1
            fi
            echo "::warning::refusal_delta_summary.json missing after refusal-delta run."
          fi
   
    

      - name: Show refusal-delta summary
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "----- refusal_delta_summary.json -----"
          cat "${{ env.PACK_DIR }}/artifacts/refusal_delta_summary.json" || true
          echo "-------------------------------------"

      - name: "Strict external evidence: require external summaries present (pre-augment, fail-closed)"
        if: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.strict_external_evidence == 'true') || startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/tags/V') }}
        shell: bash
        run: |
          set -euo pipefail
          EXT_DIR="${{ env.PACK_DIR }}/artifacts/external"
          python scripts/check_external_summaries_present.py --external_dir "$EXT_DIR" --require_metric_key

      - name: Augment status (external + top-level flags)
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          THRESH="${{ env.PACK_DIR }}/profiles/external_thresholds.yaml"
          EXT_DIR="${{ env.PACK_DIR }}/artifacts/external"

          if [ ! -f "$STATUS" ]; then
            echo "::error::status.json not found at $STATUS"
            exit 1
          fi
          if [ ! -f "$THRESH" ]; then
            echo "::error::external thresholds not found at $THRESH"
            exit 1
          fi

          echo "::group::augment_status.py preflight"

          echo "PWD=$(pwd)"
          echo "GITHUB_REF=${GITHUB_REF:-}"
          echo "GITHUB_SHA=${GITHUB_SHA:-}"
          echo "GITHUB_WORKSPACE=${GITHUB_WORKSPACE:-}"
          echo "GIT_SHA=$(git rev-parse HEAD)"

          echo "STATUS=$STATUS"
          echo "THRESH=$THRESH"
          echo "EXT_DIR=$EXT_DIR"

          PACK_DIR_DERIVED="$(dirname "$(dirname "$STATUS")")"
          AUGMENT="${PACK_DIR_DERIVED}/tools/augment_status.py"

          echo "PACK_DIR_DERIVED=$PACK_DIR_DERIVED"
          echo "AUGMENT=$AUGMENT"

          if [ ! -f "$AUGMENT" ]; then
            echo "::error::augment_status.py not found at $AUGMENT"
            exit 1
          fi

          ls -la "$AUGMENT"
          wc -l "$AUGMENT"
          sha256sum "$AUGMENT"

          nl -ba "$AUGMENT" | sed -n '340,370p' || true

          echo "::endgroup::"

          python -m py_compile "$AUGMENT"

          python "$AUGMENT" \
            --status "$STATUS" \
            --thresholds "$THRESH" \
            --external_dir "$EXT_DIR"
     
      - name: "ci: schema validate status.json (status_v1)"
        shell: bash
        run: |
          set -euo pipefail

          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          SCHEMA="$GITHUB_WORKSPACE/schemas/status/status_v1.schema.json"

          python tools/validate_status_schema.py \
            --schema "$SCHEMA" \
            --status "$STATUS"

     

          
           echo "::error::status.json not found at $STATUS"
            exit 1
          fi
          if [ ! -f "$SCHEMA" ]; then
            echo "::error::status schema not found at $SCHEMA"
            exit 1
          fi

          export STATUS
          export SCHEMA

          python - <<'PY'
          import json, os, sys
          from jsonschema import Draft202012Validator

          schema_path = os.environ["SCHEMA"]
          status_path = os.environ["STATUS"]

          with open(schema_path, "r", encoding="utf-8") as f:
              schema = json.load(f)

          Draft202012Validator.check_schema(schema)
          v = Draft202012Validator(schema)

          with open(status_path, "r", encoding="utf-8") as f:
              inst = json.load(f)

          errors = sorted(v.iter_errors(inst), key=lambda e: (list(e.path), e.message))
          if errors:
              print("::error::status.json schema validation failed:")
              for e in errors[:50]:
                  path = ".".join([str(p) for p in e.path]) or "<root>"
                  print(f"::error::{path}: {e.message}")
              sys.exit(1)

          print("OK: status.json is schema-valid (status_v1)")
          PY
   
     
      - name: Export final summary (post-augment)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/status_to_summary.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::status_to_summary.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status.json not found at $STATUS; skipping final summary."
            exit 0
          fi

          # Default outputs: artifacts/status_summary.md + artifacts/status_summary.json
          python "$SCRIPT" --status "$STATUS"

      - name: "ci: forbid demo status on version tags"
        if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/tags/V')
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$STATUS" ]; then
            echo "::error::status.json not found at $STATUS"
            exit 1
          fi

          export STATUS
          python - <<'PY'
          import json, os, sys

          p = os.environ["STATUS"]
          try:
            with open(p, "r", encoding="utf-8") as f:
              s = json.load(f)
          except Exception as e:
            print(f"::error::failed to parse status.json: {e}")
            sys.exit(1)

          v = str(s.get("version", ""))
          if "demo" in v.lower():
            print(f"::error::demo status.version is not allowed on version tags: {v}")
            sys.exit(1)

          print(f"OK: non-demo status.version on tag: {v}")
          PY

      - name: "ci: enforce gates via check_gates (policy-derived)"
        shell: bash
        run: |
          set -euo pipefail

          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$STATUS" ]; then
            echo "::error::status.json not found at $STATUS"
            exit 1
          fi

          # Default: core_required for branch builds
          POLICY_SET="core_required"

          # Version tags: enforce full required gate set (release-grade, fail-closed)
          if [[ "${GITHUB_REF:-}" == refs/tags/v* || "${GITHUB_REF:-}" == refs/tags/V* ]]; then
            POLICY_SET="required"
          fi

          # Manual strict runs should behave like release-grade gating too
          if [[ "${GITHUB_EVENT_NAME:-}" == "workflow_dispatch" ]]; then
            STRICT="$(jq -r '.inputs.strict_external_evidence // "false"' "$GITHUB_EVENT_PATH")"
            if [[ "$STRICT" == "true" ]]; then
              POLICY_SET="required"
            fi
          fi

          # Canonical helper (fail-closed, no PyYAML dependency)
          REQ_STR="$(python tools/policy_to_require_args.py --policy pulse_gate_policy_v0.yml --set "$POLICY_SET" --format space)"
          read -r -a REQ <<< "$REQ_STR"

          if (( ${#REQ[@]} == 0 )); then
            echo "::error::derived gate set is empty: ${POLICY_SET}"
            exit 1
          fi

          echo "Enforcing policy gate set: ${POLICY_SET} (${#REQ[@]} gates)"
          printf '%s\n' "${REQ[@]}" | sed 's/^/ - /'

          python "${{ env.PACK_DIR }}/tools/check_gates.py" \
            --status "$STATUS" \
            --require "${REQ[@]}"
  

      - name: Gate registry sync check
        shell: bash
        run: |
          set -euo pipefail
          python tools/check_gate_registry_sync.py \
            --status "${{ env.PACK_DIR }}/artifacts/status.json" \
            --registry pulse_gate_registry_v0.yml \
            --emit-stubs

      - name: Policy ↔ registry consistency check
        shell: bash
        run: |
          set -euo pipefail

          python tools/tools/check_policy_registry_consistency.py \
            --registry pulse_gate_registry_v0.yml \
            --policy pulse_gate_policy_v0.yml \
            --sets required

          python tools/tools/check_policy_registry_consistency.py \
            --registry pulse_gate_registry_v0.yml \
            --policy pulse_gate_policy_v0.yml \
            --sets core_required

          python - <<'PY'
          import sys
          import yaml

          with open("pulse_gate_policy_v0.yml", "r", encoding="utf-8") as f:
              pol = yaml.safe_load(f) or {}

          # Canonical schema is gates.*; accept legacy sets.* as fallback.
          gates = pol.get("gates")
          if gates is None and isinstance(pol.get("sets"), dict):
              gates = pol.get("sets")

          if not isinstance(gates, dict):
              print("::error::pulse_gate_policy_v0.yml is missing expected 'gates' mapping (or legacy 'sets' mapping).")
              sys.exit(1)

          core = set(gates.get("core_required") or [])
          req = set(gates.get("required") or [])

          missing = sorted(core - req)
          if missing:
              print("::error::gates.core_required must be a subset of gates.required.")
              for g in missing:
                  print(f"::error::- {g}")
              sys.exit(1)

          print("OK: core_required ⊆ required")
          PY

      - name: Compute stability map
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/compute_stability_map.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::compute_stability_map.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Render stability map
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/render_stability_map.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::render_stability_map.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Compute field-level stability
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/field_stability.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::field_stability.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Compute field-level gating scores
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/field_v0.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::field_v0.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Compute EPF overlay
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/compute_epf_overlay_v0.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::compute_epf_overlay_v0.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Generate PULSE snapshot report (HTML)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/status_to_html_snapshot.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::status_to_html_snapshot.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Generate PULSE snapshot report (Markdown)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/status_to_md_snapshot.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::status_to_md_snapshot.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Write PULSE summary
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/write_pulse_summary.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::write_pulse_summary.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Prepare overlay outputs
        shell: bash
        run: |
          set -euo pipefail

          OVERLAY_DIR="${{ env.PACK_DIR }}/artifacts/overlay"
          mkdir -p "$OVERLAY_DIR"

          copy_if_exists () {
            local src="$1"
            local dst="$2"
            if [ -f "$src" ]; then
              cp "$src" "$dst"
            else
              echo "::warning::missing overlay artifact: $src"
            fi
          }

          copy_if_exists "${{ env.PACK_DIR }}/artifacts/stability_map_v0.json" "$OVERLAY_DIR/stability_map_v0.json"
          copy_if_exists "${{ env.PACK_DIR }}/artifacts/stability_map_v0.md" "$OVERLAY_DIR/stability_map_v0.md"
          copy_if_exists "${{ env.PACK_DIR }}/artifacts/stability_map_v0.svg" "$OVERLAY_DIR/stability_map_v0.svg"

          copy_if_exists "${{ env.PACK_DIR }}/artifacts/field_stability_v0.json" "$OVERLAY_DIR/field_stability_v0.json"
          copy_if_exists "${{ env.PACK_DIR }}/artifacts/field_stability_v0.md" "$OVERLAY_DIR/field_stability_v0.md"

          copy_if_exists "${{ env.PACK_DIR }}/artifacts/field_v0.json" "$OVERLAY_DIR/field_v0.json"
          copy_if_exists "${{ env.PACK_DIR }}/artifacts/field_v0.md" "$OVERLAY_DIR/field_v0.md"

          copy_if_exists "${{ env.PACK_DIR }}/artifacts/g_epf_overlay_v0.json" "$OVERLAY_DIR/g_epf_overlay_v0.json"
          copy_if_exists "${{ env.PACK_DIR }}/artifacts/g_epf_overlay_v0.md" "$OVERLAY_DIR/g_epf_overlay_v0.md"

      - name: Export overlay HTML summary
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/overlay_to_html_summary.py"
          OVERLAY_DIR="${{ env.PACK_DIR }}/artifacts/overlay"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::overlay_to_html_summary.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --overlay_dir "$OVERLAY_DIR"

      - name: Copy overlay HTML to report root
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          SRC="${{ env.PACK_DIR }}/artifacts/overlay/overlay_summary.html"
          DST="${{ env.PACK_DIR }}/artifacts/overlay_summary.html"

          if [ ! -f "$SRC" ]; then
            echo "::warning::overlay_summary.html not found at $SRC; skipping copy."
            exit 0
          fi

          cp "$SRC" "$DST"

      - name: Write status.json key-order diagnosis (for debugging)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/status_key_order_diagnosis.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::status_key_order_diagnosis.py not found at $SCRIPT; skipping."
            exit 0
          fi

          python "$SCRIPT" --status "$STATUS"

      - name: Write separation-phase report (HTML)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/separation_phase_report.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::separation_phase_report.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Write separation-phase report (Markdown)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/separation_phase_report_md.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::separation_phase_report_md.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Write separation-phase per-gate matrix
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/separation_phase_matrix.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::separation_phase_matrix.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Write separation-phase per-gate matrix (MD)
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/separation_phase_matrix_md.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::separation_phase_matrix_md.py not found at $SCRIPT; skipping."
            exit 0
          fi
          python "$SCRIPT" --status "$STATUS"

      - name: Generate separation-phase overlay for snapshot
        shell: bash
        run: |
          set -euo pipefail
          SCRIPT="${{ env.PACK_DIR }}/tools/compute_separation_phase_overlay_v0.py"
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          if [ ! -f "$SCRIPT" ]; then
            echo "::warning::compute_separation_phase_overlay_v0.py not found at $SCRIPT; skipping."
            exit 0
          fi
          if [ ! -f "$STATUS" ]; then
            echo "::warning::status.json not found at $STATUS; skipping separation overlay."
            exit 0
          fi

          python "$SCRIPT" --status "$STATUS"

      - name: Release-grade artifact postconditions
        if: always()
        shell: bash
        run: |
          set -euo pipefail

          PACK_DIR="${{ env.PACK_DIR }}"

          # Release-grade runs:
          # - version tags (v*/V*)
          # - workflow_dispatch with strict_external_evidence=true
          IS_RELEASE=0
          if [[ "${GITHUB_REF:-}" == refs/tags/v* || "${GITHUB_REF:-}" == refs/tags/V* ]]; then
            IS_RELEASE=1
          fi
          if [[ "${GITHUB_EVENT_NAME:-}" == "workflow_dispatch" ]]; then
            STRICT="$(jq -r '.inputs.strict_external_evidence // "false"' "$GITHUB_EVENT_PATH")"
            if [[ "$STRICT" == "true" ]]; then
              IS_RELEASE=1
            fi
          fi

          req_files=(
            "$PACK_DIR/artifacts/status_baseline.json"
            "$PACK_DIR/artifacts/status.json"
            "$PACK_DIR/artifacts/status_summary_baseline.json"
            "$PACK_DIR/artifacts/status_summary.json"
          )

          missing=0
          for f in "${req_files[@]}"; do
            if [ ! -f "$f" ]; then
              if (( IS_RELEASE )); then
                echo "::error::missing required artifact on release-grade run: $f"
                missing=1
              else
                echo "::warning::missing artifact: $f"
              fi
            fi
          done

          if (( IS_RELEASE )) && (( missing )); then
            echo "::error::release-grade artifacts incomplete; failing closed."
            exit 1
          fi

          echo "OK: artifact postconditions satisfied (IS_RELEASE=$IS_RELEASE)"
     
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # pinned
        with:
          name: pulse-report
          if-no-files-found: warn
          path: |
            ${{ env.PACK_DIR }}/artifacts/**
            badges/*.svg
            reports/junit.xml
            reports/sarif.json

  tools-tests:
    name: Tools smoke tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # pinned
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # pinned
        with:
          python-version: "3.11"

      - name: Install Python deps (tools-tests)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt

      - name: Run exporter + governance smoke tests
        shell: bash
        run: |
          set -euo pipefail

          tests=(
            "tests/test_exporters.py"
            "tests/test_tools_governance_smoke.py"
            "tests/test_check_external_summaries_present.py"
            "tests/test_augment_status_smoke.py"
            "tests/test_run_all_mode_contract.py"
            "tests/test_pack_tools_compile.py"
          )
      

          echo "Fail-fast: py_compile smoke scripts"
          python -m py_compile "${tests[@]}"

          echo "Run smoke scripts (one-by-one for clean logs)"
          for t in "${tests[@]}"; do
            echo "==> python $t"
            python "$t"
          done

          echo "Exporter + governance smoke tests OK"
