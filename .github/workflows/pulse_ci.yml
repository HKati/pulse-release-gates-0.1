name: PULSE CI

on:
  push:
    branches: [main]
    paths-ignore:
      - "docs/**"
      - "**/*.md"
      - "badges/**"
      - "reports/**"
  pull_request:
    branches: [main]
    paths-ignore:
      - "docs/**"
      - "**/*.md"
      - "badges/**"
      - "reports/**"
  workflow_dispatch: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Least privilege by default: this workflow must not write to the repo.
permissions:
  contents: read

jobs:
  pulse:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # pinned
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Enforce changelog for policy/spec changes
        shell: bash
        run: |
          set -euo pipefail

          # Determine diff range depending on event type.
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
          else
            echo "Skipping changelog enforcement: unsupported event '${{ github.event_name }}'."
            exit 0
          fi

          # Handle edge cases (e.g., first commit or unusual events).
          if [[ -z "${BASE}" || "${BASE}" == "0000000000000000000000000000000000000000" ]]; then
            echo "Skipping changelog enforcement: BASE SHA is empty/zero."
            exit 0
          fi

          echo "Changelog enforcement diff range: ${BASE}..${HEAD}"

          CHANGED="$(git diff --name-only "${BASE}" "${HEAD}" || true)"
          echo "${CHANGED}" | sed 's/^/changed: /' || true

          # Files that can change release-gating meaning and therefore require changelog coverage.
          SEMANTIC_PATTERN='^(pulse_gate_policy_v0\.yml|metrics/specs/|schemas/dataset_manifest\.schema\.json|examples/dataset_manifest\.example\.json)'

          # Changelog file containing semantic change notes.
          CHANGELOG_PATH='docs/policy/CHANGELOG.md'

          # If nothing semantic changed, do nothing.
          SEMANTIC_CHANGED="$(echo "${CHANGED}" | grep -E "${SEMANTIC_PATTERN}" || true)"
          if [[ -z "${SEMANTIC_CHANGED}" ]]; then
            echo "No semantic policy/spec/contract changes detected; changelog update not required."
            exit 0
          fi

          if [[ ! -f "${CHANGELOG_PATH}" ]]; then
            echo "::error::Changelog not found at ${CHANGELOG_PATH}."
            exit 1
          fi

          export SEMANTIC_CHANGED
          export CHANGELOG_PATH

          python3 - <<'PY'
          import os, re, sys
          from pathlib import Path

          changed = [ln.strip() for ln in os.environ["SEMANTIC_CHANGED"].splitlines() if ln.strip()]
          changelog_path = Path(os.environ["CHANGELOG_PATH"])
          text = changelog_path.read_text(encoding="utf-8", errors="replace")

          # Accept both "## Unreleased" and "## [Unreleased]" (robust, not brittle).
          m = re.search(r"^##\s*\[?\s*Unreleased\s*\]?\s*$([\s\S]*?)(?=^##\s+\S|\Z)", text, flags=re.M | re.I)
          if not m:
            print("::error::docs/policy/CHANGELOG.md is missing an 'Unreleased' section (expected '## Unreleased' or '## [Unreleased]').")
            sys.exit(1)

          unrel = m.group(1)
          unrel_l = unrel.lower()

          def stem_variants(stem: str):
            s = stem.lower()
            s2 = re.sub(r"_v\d+$", "", s)  # drop _v0 suffix (q3_fairness_v0 -> q3_fairness)
            return {
              s,
              s2,
              s2.replace("_", " "),
              s2.replace("_", "-"),
            }

          def parse_spec_id_version(path: Path):
            # Minimal YAML parsing for the spec block: look for top-level "spec:" then id/version inside.
            in_spec = False
            spec_id = None
            spec_ver = None

            for raw in path.read_text(encoding="utf-8", errors="replace").splitlines():
              line = raw.rstrip("\n")

              # enter spec block on exact top-level "spec:"
              if not in_spec and re.match(r"^spec:\s*$", line):
                in_spec = True
                continue

              if in_spec:
                # leaving spec block when another top-level key starts (non-empty and no leading spaces)
                if re.match(r"^[A-Za-z0-9_]+\s*:\s*$", line) and not line.startswith(" "):
                  break

                # capture id and version lines inside spec
                m_id = re.match(r"^\s*id:\s*(.+?)\s*$", line)
                if m_id and spec_id is None:
                  spec_id = m_id.group(1).strip().strip('"').strip("'")
                  continue

                m_ver = re.match(r"^\s*version:\s*(.+?)\s*$", line)
                if m_ver and spec_ver is None:
                  spec_ver = m_ver.group(1).strip().strip('"').strip("'")
                  continue

                if spec_id and spec_ver:
                  break

            return spec_id, spec_ver

          missing = []

          for p in changed:
            if p.startswith("metrics/specs/") and p.endswith(".yml"):
              spec_path = Path(p)
              if not spec_path.exists():
                missing.append((p, "spec file missing in workspace"))
                continue

              spec_id, spec_ver = parse_spec_id_version(spec_path)

              # Fallbacks: use filename stem if spec.id missing (but warn via error).
              file_stem = spec_path.stem.lower()
              want_any = set()

              if spec_id:
                want_any |= stem_variants(spec_id)
              else:
                want_any |= stem_variants(file_stem)

              # Require at least one identifier token AND the version string to appear in Unreleased.
              id_ok = any(tok and tok in unrel_l for tok in want_any)
              ver_ok = (spec_ver is not None) and (str(spec_ver).strip() in unrel)

              if not id_ok or not ver_ok:
                reason = []
                if not id_ok:
                  reason.append(f"missing id token (expected one of: {sorted(want_any)})")
                if spec_ver is None:
                  reason.append("spec.version not found in file")
                elif not ver_ok:
                  reason.append(f"missing version '{spec_ver}' in Unreleased")
                missing.append((p, "; ".join(reason)))
              continue

            if p == "pulse_gate_policy_v0.yml":
              if "pulse_gate_policy_v0" not in unrel_l:
                missing.append((p, "expected mention of 'pulse_gate_policy_v0' in Unreleased"))
              continue

            if p in ("schemas/dataset_manifest.schema.json", "examples/dataset_manifest.example.json"):
              # Accept either underscore or spaced mention.
              if ("dataset_manifest" not in unrel_l) and ("dataset manifest" not in unrel_l):
                missing.append((p, "expected mention of 'dataset_manifest' (or 'dataset manifest') in Unreleased"))
              continue

          if missing:
            print("::error::Semantic policy/spec/contract files changed, but the Unreleased changelog does not cover them.")
            for path, why in missing:
              print(f"::error::- {path}: {why}")
            print("::error::Please add/adjust an entry under 'Unreleased' documenting the semantic change(s) and include the relevant spec.version where applicable.")
            sys.exit(1)

          print("OK: Unreleased changelog content covers all semantic changes.")
          PY

      - name: Locate PULSE pack
        shell: bash
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          PACK_DIR=""

          if [ -f "$ROOT/PULSE_safe_pack_v0/tools/run_all.py" ]; then
            PACK_DIR="$ROOT/PULSE_safe_pack_v0"
          elif [ -f "$ROOT/PULSE_safe_pack_v0.zip" ]; then
            unzip -q -o "$ROOT/PULSE_safe_pack_v0.zip"
            PACK_DIR="$ROOT/PULSE_safe_pack_v0"
          else
            RUN_ALL="$(find "$ROOT" -type f -name run_all.py -path "*/PULSE_safe_pack_v0/*" | head -n1 || true)"
            if [ -z "$RUN_ALL" ]; then
              echo "::error::PULSE pack not found in repo root."
              exit 1
            fi
            PACK_DIR="$(dirname "$(dirname "$RUN_ALL")")"
          fi

          echo "PACK_DIR=$PACK_DIR" >> "$GITHUB_ENV"
          echo "PACK_DIR resolved to: $PACK_DIR"

      - name: Set up Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # pinned
        with:
          python-version: "3.11"

      - name: Install Python deps
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install pyyaml

      - name: Ensure directories
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "${{ env.PACK_DIR }}/artifacts/external"
          mkdir -p "${{ env.PACK_DIR }}/examples"
          mkdir -p reports
          mkdir -p badges

      - name: Run PULSE
        shell: bash
        run: |
          set -euo pipefail
          python "${{ env.PACK_DIR }}/tools/run_all.py"

      - name: Compute refusal-delta (policy-config)
        shell: bash
        run: |
          set -euo pipefail
          RD="${{ env.PACK_DIR }}/tools/refusal_delta_calc.py"
          if [ ! -f "$RD" ]; then
            RD="$(find "${{ env.PACK_DIR }}" -type f -name 'refusal_delta_calc.py' | head -n1 || true)"
          fi
          if [ -z "$RD" ] || [ ! -f "$RD" ]; then
            echo "::error::refusal_delta_calc.py not found under ${{ env.PACK_DIR }}"
            exit 1
          fi

          REAL="${{ env.PACK_DIR }}/examples/refusal_pairs.jsonl"
          if [ -f "$REAL" ]; then
            PAIRS="$REAL"
            echo "Using REAL pairs: $PAIRS"
          else
            PAIRS="${{ env.PACK_DIR }}/examples/refusal_pairs_sample.jsonl"
            if [ ! -f "$PAIRS" ]; then
              printf '%s\n' '{"pair_id":"ex1","plain_refusal":true,"tool_refusal":false}' > "$PAIRS"
              printf '%s\n' '{"pair_id":"ex2","plain_refusal":true,"tool_refusal":true}' >> "$PAIRS"
              printf '%s\n' '{"pair_id":"ex3","plain_refusal":false,"tool_refusal":false}' >> "$PAIRS"
              printf '%s\n' '{"pair_id":"ex4","plain_refusal":true,"tool_refusal":false}' >> "$PAIRS"
            fi
            echo "Using SAMPLE pairs: $PAIRS"
          fi

          POL="${{ env.PACK_DIR }}/profiles/pulse_policy.yaml"
          python "$RD" \
            --pairs "$PAIRS" \
            --out "${{ env.PACK_DIR }}/artifacts/refusal_delta_summary.json" \
            --policy_config "$POL"

      - name: Show refusal-delta summary
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          echo "----- refusal_delta_summary.json -----"
          cat "${{ env.PACK_DIR }}/artifacts/refusal_delta_summary.json" || true
          echo "-------------------------------------"

      - name: Augment status (external + top-level flags)
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          THRESH="${{ env.PACK_DIR }}/profiles/external_thresholds.yaml"
          EXT_DIR="${{ env.PACK_DIR }}/artifacts/external"

          if [ ! -f "$STATUS" ]; then
            echo "::error::status.json not found at $STATUS"
            exit 1
          fi
          if [ ! -f "$THRESH" ]; then
            echo "::error::external thresholds not found at $THRESH"
            exit 1
          fi

          python "${{ env.PACK_DIR }}/tools/augment_status.py" \
            --status "$STATUS" \
            --thresholds "$THRESH" \
            --external_dir "$EXT_DIR"

      - name: External detector summaries (visibility)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          EXT_DIR="${{ env.PACK_DIR }}/artifacts/external"
          if [ -d "$EXT_DIR" ]; then
            echo "External summary directory: $EXT_DIR"
            ls -la "$EXT_DIR" || true
            if ! find "$EXT_DIR" -maxdepth 1 -type f | grep -q .; then
              echo "::warning::No external detector summaries found. external_all_pass may be trivially true (fail-open)."
            fi
          else
            echo "::warning::External summary directory missing: $EXT_DIR"
          fi

      - name: Show gates snapshot
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          echo "----- status.json (gates) -----"
          if [ -f "$STATUS" ]; then
            if command -v jq >/dev/null 2>&1; then
              jq '.gates' "$STATUS" || cat "$STATUS" || true
            else
              cat "$STATUS" || true
            fi
          else
            echo "::warning::No status.json produced."
          fi
          echo "--------------------------------"

      - name: Generate Anchor Integrity overlay artifacts (diagnostic-only)
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${SOURCE_DATE_EPOCH:-}" ]; then
            SOURCE_DATE_EPOCH="$(git log -1 --format=%ct)"
            echo "SOURCE_DATE_EPOCH=$SOURCE_DATE_EPOCH" >> "$GITHUB_ENV"
          fi

          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          OUT_JSON="${{ env.PACK_DIR }}/artifacts/anchor_integrity_v0.json"
          OUT_MD="${{ env.PACK_DIR }}/artifacts/anchor_integrity_overlay_v0.md"

          python scripts/anchor_integrity_adapter_v0.py --status "$STATUS" --out "$OUT_JSON"
          python scripts/check_anchor_integrity_v0_contract.py --in "$OUT_JSON"
          python scripts/render_anchor_integrity_overlay_v0_md.py --in "$OUT_JSON" --out "$OUT_MD"

      - name: Generate Separation Phase overlay artifacts (diagnostic, for Pages)
        if: always()
        continue-on-error: true
        shell: bash
        env:
          OUT_JSON: ${{ env.PACK_DIR }}/artifacts/separation_phase_v0.json
          OUT_MD: ${{ env.PACK_DIR }}/artifacts/separation_phase_overlay_v0.md
          OUT_HTML: ${{ env.PACK_DIR }}/artifacts/separation_phase_overlay.html
        run: |
          set -euo pipefail

          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          # 1) Overlay JSON (adapter is fail-closed: emits UNKNOWN/CLOSED if status missing)
          python scripts/separation_phase_adapter_v0.py \
            --status "$STATUS" \
            --out "$OUT_JSON" \
            --commit "${GITHUB_SHA}"

          # 2) Contract check (diagnostic-only; do not block main gates)
          python scripts/check_separation_phase_v0_contract.py --in "$OUT_JSON"

          # 3) Human summary (Markdown)
          python scripts/render_separation_phase_overlay_v0_md.py \
            --overlay "$OUT_JSON" \
            --status "$STATUS" \
            --out "$OUT_MD"

          # 4) Tiny static HTML viewer (no deps) â€“ good for Pages browsing
          python - <<'PY'
          import json, html, os
          from pathlib import Path

          out_json = Path(os.environ["OUT_JSON"])
          out_html = Path(os.environ["OUT_HTML"])

          d = json.loads(out_json.read_text(encoding="utf-8"))

          state = d.get("state", "UNKNOWN")
          rec = d.get("recommendation") or {}
          action = rec.get("gate_action", "CLOSED")
          rationale = rec.get("rationale", "")

          inv = d.get("invariants") or {}
          os_ = inv.get("order_stability") or {}
          score = os_.get("score")
          n_runs = os_.get("n_runs")
          unstable = (os_.get("unstable_gates") or [])[:50]

          ts = inv.get("threshold_sensitivity") or {}
          thresh = (ts.get("threshold_like_gates") or [])[:50]

          def esc(x):
            return html.escape("" if x is None else str(x))

          unstable_text = "\n".join(map(str, unstable)) if unstable else "(none)"
          thresh_text = "\n".join(map(str, thresh)) if thresh else "(none)"

          body = f"""<!doctype html>
          <html lang="en">
          <head>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <title>Separation Phase Overlay (v0)</title>
            <style>
              body {{ font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
                     margin: 24px; max-width: 980px; }}
              code, pre {{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }}
              .k {{ color: #555; }}
              .box {{ padding: 12px 14px; border: 1px solid #ddd; border-radius: 8px; background: #fafafa; }}
              pre {{ padding: 10px 12px; border: 1px solid #eee; border-radius: 8px; background: #fff; overflow-x: auto; }}
            </style>
          </head>
          <body>
            <h1>Separation Phase Overlay (v0)</h1>

            <div class="box">
              <p><span class="k">State:</span> <strong>{esc(state)}</strong></p>
              <p><span class="k">Recommendation:</span> <strong>{esc(action)}</strong></p>
              <p><span class="k">Rationale:</span> {esc(rationale)}</p>
              <p><span class="k">Order-stability score:</span> <strong>{esc(score)}</strong>
                 <span class="k">(n_runs={esc(n_runs)})</span></p>
            </div>

            <h2>Artifacts</h2>
            <ul>
              <li><a href="separation_phase_v0.json">separation_phase_v0.json</a></li>
              <li><a href="separation_phase_overlay_v0.md">separation_phase_overlay_v0.md</a></li>
              <li><a href="status.json">status.json</a></li>
            </ul>

            <h2>Unstable gates (first 50)</h2>
            <pre>{esc(unstable_text)}</pre>

            <h2>Threshold-like gates (first 50)</h2>
            <pre>{esc(thresh_text)}</pre>

            <p class="k">
              Diagnostic-only surface. Must not redefine normative PULSE gating semantics.
            </p>
          </body>
          </html>
          """
          out_html.write_text(body + "\n", encoding="utf-8")
          print(f"OK: wrote {out_html}")
          PY

      - name: Enforce required gates (policy-driven)
        shell: bash
        run: |
          set -euo pipefail
          # NOTE: do NOT quote $REQ when passing to --require, because check_gates expects
          # each gate id as a separate CLI argument.
          REQ="$(python tools/policy_to_require_args.py --policy pulse_gate_policy_v0.yml --set required)"
          echo "Required gates (from policy): $REQ"

          python "${{ env.PACK_DIR }}/tools/check_gates.py" \
            --status "${{ env.PACK_DIR }}/artifacts/status.json" \
            --require $REQ

      - name: Export JUnit & SARIF
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          if [ ! -f "$STATUS" ]; then
            echo "::warning::No status.json found; skipping JUnit/SARIF export."
            exit 0
          fi

          cp "$STATUS" status.json

          python "${{ env.PACK_DIR }}/tools/status_to_junit.py"
          python "${{ env.PACK_DIR }}/tools/status_to_sarif.py"

          if [ -f junit.xml ]; then
            mv junit.xml reports/junit.xml
          fi
          if [ -f sarif.json ]; then
            mv sarif.json reports/sarif.json
          fi

      - name: Generate badges (artifact only)
        if: always()
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"
          BADGE_TOOL="${{ env.PACK_DIR }}/tools/ci/update_badges.py"

          if [ ! -f "$STATUS" ]; then
            echo "::warning::No status.json found; skipping badge generation."
            exit 0
          fi
          if [ ! -f "$BADGE_TOOL" ]; then
            echo "::warning::update_badges.py not found; skipping badge generation."
            exit 0
          fi

          python "$BADGE_TOOL" \
            --status "$STATUS" \
            --assets badges \
            --out badges

      - name: Workflow summary
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          STATUS="${{ env.PACK_DIR }}/artifacts/status.json"

          echo "## PULSE CI summary" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          if [ -f "$STATUS" ] && command -v jq >/dev/null 2>&1; then
            echo "### Gates" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo '```json' >> "$GITHUB_STEP_SUMMARY"
            jq '.gates' "$STATUS" >> "$GITHUB_STEP_SUMMARY" || true
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          else
            echo "_No status.json produced (or jq missing)._ " >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # pinned
        with:
          name: pulse-report
          if-no-files-found: warn
          path: |
            ${{ env.PACK_DIR }}/artifacts/**
            badges/*.svg
            reports/junit.xml
            reports/sarif.json

  tools-tests:
    name: Tools smoke tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # pinned
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # pinned
        with:
          python-version: "3.11"

      - name: Run exporter smoke tests
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
          import pathlib, subprocess, sys

          root = pathlib.Path(".").resolve()
          (root / "tests" / "out").mkdir(parents=True, exist_ok=True)

          subprocess.check_call([sys.executable, "tests/test_exporters.py"])
          print("Exporter smoke tests OK")
          PY
