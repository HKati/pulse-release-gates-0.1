name: repo-hygiene

on:
  pull_request: {}
  push:
    branches: ["main"]

permissions:
  contents: read

jobs:
  hygiene_guardrails:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # pinned
        with:
          python-version: "3.11"

      - name: Install PyYAML (for workflow YAML guard)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install pyyaml

      - name: "Repo hygiene: validate workflow YAML files (fail-closed)"
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import re
          import sys
          import pathlib
          import yaml

          root = pathlib.Path(".github/workflows")
          files = sorted(list(root.glob("*.yml")) + list(root.glob("*.yaml")))

          if not files:
              print("::warning::No workflow files found under .github/workflows/")
              sys.exit(0)

          # Guardrail: unquoted ':' + whitespace inside a step name can break YAML parsing in GitHub Actions.
          colon_name_re = re.compile(r'^\s*-\s*name:\s+[^"\'].*:\s+.*$', re.MULTILINE)

          ok = True

          for f in files:
              text = f.read_text(encoding="utf-8", errors="replace")

              m = colon_name_re.search(text)
              if m:
                  line_no = text[:m.start()].count("\n") + 1
                  print(
                      f"::error file={f},line={line_no}::"
                      "Unquoted ':' in step name. Quote the value or use a block scalar (name: >-)."
                  )
                  ok = False

              try:
                  obj = yaml.safe_load(text)
              except yaml.YAMLError as e:
                  # Best-effort line/col extraction
                  line = None
                  col = None
                  mark = getattr(e, "problem_mark", None)
                  if mark is not None:
                      line = mark.line + 1
                      col = mark.column + 1
                  loc = f",line={line},col={col}" if line is not None and col is not None else ""
                  msg = str(e).replace("\n", " | ")
                  print(f"::error file={f}{loc}::YAML parse error: {msg}")
                  ok = False
                  continue

              if obj is None:
                  print(f"::error file={f}::Workflow YAML is empty (safe_load returned None).")
                  ok = False
                  continue

              if not isinstance(obj, dict):
                  print(f"::error file={f}::Workflow YAML must be a mapping at top-level (got {type(obj).__name__}).")
                  ok = False
                  continue

          if not ok:
              sys.exit(1)

          print(f"OK: validated {len(files)} workflow file(s).")
          PY

      - name: "Repo hygiene: forbid case-insensitive path collisions (file/file + file/dir)"
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import sys
          from collections import defaultdict
          import subprocess

          files = subprocess.check_output(["git", "ls-files"], text=True).splitlines()

          # 1) File-vs-file collisions: two tracked files whose full paths differ only by case.
          files_by_lower = defaultdict(list)

          # 2) File-vs-directory collisions: a tracked file path conflicts with a directory name
          #    implied by other tracked files.
          #
          # Example:
          #   - file "Foo"
          #   - file "foo/bar.txt"  (implies directory "foo/")
          # On case-insensitive filesystems, this fails checkout.
          dir_required_by_lower = defaultdict(set)  # dir_lower -> {example file that requires this directory}

          for f in files:
              fl = f.lower()
              files_by_lower[fl].append(f)

              parts = f.split("/")
              # Collect all directory prefixes for this file path
              for i in range(1, len(parts)):
                  d = "/".join(parts[:i])
                  dir_required_by_lower[d.lower()].add(f)

          file_file = {k: v for k, v in files_by_lower.items() if len(v) > 1}

          file_dir = {}
          for d_lower, examples in dir_required_by_lower.items():
              if d_lower in files_by_lower:
                  file_dir[d_lower] = (files_by_lower[d_lower], sorted(examples))

          if not file_file and not file_dir:
              print("OK: no case-insensitive path collisions.")
              sys.exit(0)

          if file_file:
              print("ERROR: case-insensitive file-vs-file collisions detected:")
              for k in sorted(file_file.keys()):
                  print(" - " + "  |  ".join(sorted(file_file[k])))

          if file_dir:
              print("ERROR: case-insensitive file-vs-directory collisions detected:")
              for d_lower in sorted(file_dir.keys()):
                  file_paths, examples = file_dir[d_lower]
                  print(f" - File path(s) collide with directory '{d_lower}/': " + "  |  ".join(sorted(file_paths)))
                  for ex in examples[:10]:
                      print("     requires directory for: " + ex)
                  if len(examples) > 10:
                      print(f"     ... and {len(examples) - 10} more")

          sys.exit(1)
          PY

      - name: "Repo hygiene: forbid ignored workflows under github/workflows/"
        shell: bash
        run: |
          set -euo pipefail
          bad="$(git ls-files | grep -E '^github/workflows/.*\.ya?ml$' || true)"
          if [ -n "$bad" ]; then
            echo "::error::Found workflow files under github/workflows/ (ignored by GitHub Actions)."
            echo "Move these files under .github/workflows/:"
            echo "$bad" | sed 's/^/ - /'
            exit 1
          fi
          echo "OK: no ignored workflows under github/workflows/."

      - name: "Repo hygiene: forbid nested fixtures"
        shell: bash
        run: |
          set -euo pipefail
          bad="$(git ls-files | grep -E '^tests/fixtures/.*/tests/fixtures/' || true)"
          if [ -n "$bad" ]; then
            echo "::error::Nested fixture path detected (tests/fixtures/**/tests/fixtures/**)."
            echo "$bad" | sed 's/^/ - /'
            exit 1
          fi
          echo "OK: no nested fixtures detected."
