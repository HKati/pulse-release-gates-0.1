name: workflow-lint

on:
  pull_request:
    paths:
      - ".github/workflows/*.yml"
      - ".github/workflows/*.yaml"
  push:
    branches: ["main"]
    paths:
      - ".github/workflows/*.yml"
      - ".github/workflows/*.yaml"

permissions:
  contents: read

jobs:
  lint_workflows:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Setup Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
        with:
          python-version: "3.11"

      - name: Install PyYAML (for workflow parsing)
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --disable-pip-version-check "pyyaml==6.0.2"

      - name: Validate workflow YAML (parse + guardrails)
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import re
          import sys
          import pathlib

          import yaml

          root = pathlib.Path(".github/workflows")
          files = sorted(list(root.glob("*.yml")) + list(root.glob("*.yaml")))

          if not files:
              print("::warning::No workflow files found under .github/workflows/")
              sys.exit(0)

          # Guardrail: this is the exact failure mode you hit.
          # Unquoted ':' followed by whitespace inside a step name can break YAML parsing in GitHub Actions.
          colon_name_re = re.compile(r'^\s*-\s*name:\s+[^"\'].*:\s+.*$', re.MULTILINE)

          # Loop-risk guard: detect `git ... commit` lines, including valid global flags before the subcommand
          # (e.g. `git -c user.name=bot commit -m ...`, `git --no-pager commit -m ...`).
          # The negative lookahead prevents flags-without-args from accidentally consuming the `commit` token.
          commit_line_re = re.compile(
              r'^\s*git(?:\s+(?:-\S+|--\S+)(?:\s+(?!commit(?:\s|$))\S+)?)*\s+commit(?:\s|$).*$',
              re.MULTILINE | re.IGNORECASE
          )

          def has_contents_write(perms):
              if isinstance(perms, str):
                  return perms.strip().lower() == "write-all"
              if isinstance(perms, dict):
                  return str(perms.get("contents", "")).strip().lower() == "write"
              return False

          ok = True

          for f in files:
              text = f.read_text(encoding="utf-8", errors="replace")

              # Extra explicit check for the known footgun (even if parsing succeeds locally).
              m = colon_name_re.search(text)
              if m:
                  line_no = text[:m.start()].count("\n") + 1
                  print(f"::error file={f},line={line_no}::Unquoted ':' in step name. Quote the value of - name: ...")
                  ok = False

              try:
                  obj = yaml.safe_load(text)
              except yaml.YAMLError as e:
                  # Best-effort line extraction
                  line = None
                  col = None
                  mark = getattr(e, "problem_mark", None)
                  if mark is not None:
                      line = mark.line + 1
                      col = mark.column + 1
                  loc = f",line={line},col={col}" if line is not None and col is not None else ""
                  msg = str(e).replace("\n", " | ")
                  print(f"::error file={f}{loc}::YAML parse error: {msg}")
                  ok = False
                  continue

              if obj is None:
                  print(f"::error file={f}::Workflow YAML is empty (safe_load returned None).")
                  ok = False
                  continue

              if not isinstance(obj, dict):
                  print(f"::error file={f}::Workflow YAML must be a mapping at top-level (got {type(obj).__name__}).")
                  ok = False
                  continue

              # Minimal sanity: expect at least one of the canonical keys
              if not any(k in obj for k in ("on", "name", "jobs")):
                  print(f"::warning file={f}::Top-level keys look unusual (missing 'on'/'jobs').")

              # Loop-risk guard: workflows that can write back to the repo must use
              # an explicit CI bypass marker when committing generated files.
              workflow_write = has_contents_write(obj.get("permissions"))
              jobs = obj.get("jobs") if isinstance(obj.get("jobs"), dict) else {}
              job_write = any(
                  has_contents_write(j.get("permissions"))
                  for j in jobs.values()
                  if isinstance(j, dict)
              )

              if workflow_write or job_write:
                  for m in commit_line_re.finditer(text):
                      line_no = text[:m.start()].count("\n") + 1
                      line = m.group(0).lower()
                      if "[skip ci]" not in line and "[ci skip]" not in line:
                          print(
                              f"::error file={f},line={line_no}::"
                              "workflows with contents:write must use '[skip ci]' (or '[ci skip]') in git commit commands to avoid CI fix-loop risk."
                          )
                          ok = False

          if not ok:
              sys.exit(1)

          print(f"OK: validated {len(files)} workflow file(s).")
          PY
